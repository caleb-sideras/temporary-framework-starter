<div><t-header href="https://www.youtube.com/watch?v=dQw4w9WgXcQ" heading="Building The Temporary Standard"></t-header><div id="example-body"><div id='markdown'><h3 id="a-junior-developers-view-into-the-world-of-software-development">A junior developers view into the world of software development</h3>
<p>Being a novice in this field of software development hasn't stopped me from noticing bad patterns and standards that inject more code into your codebase with unlying unknown complexity - essentially a world of abstraction. I am not anti-abstraction; I very much prefer writing Go over Assembly, or using a car over a horse. But the difference with these abstractions is that they are a) necessary and b) have firm standards and therefore a stable direction in which they will progress. Most abstractions are born out of a perceived necessity of the time which naturally changes based on the times and it's respective perception. I am not anti-progress nor change; I expect every so often a new shift in the approach to software engineering will occur, and we are better for it. But when you create an abstraction to fix a problem created by abstraction which also leads to another problem requiring an abstraction - we must take a step back and re-evaluate a few things.</p>
<p>There are many examples I can provide that fit the criteria above, such as:</p>
<ol>
<li>
<p>Abstracting database access with ORMs can make simple queries easy but complex queries verbose and hard to debug. An abstraction meant to simplify can overcomplicate in the name of 'type safety'.</p>
</li>
<li>
<p>Creating many layers of inheritance in OOP can obscure where behavior is actually coming from. An abstraction meant to encapsulate can confuse.</p>
</li>
<li>
<p>Inventing new frameworks to fix limitations of old frameworks, which then gain limitations of their own over time. The cycle never ends (I am contributing to this).</p>
</li>
<li>
<p>GraphQL... API churn</p>
</li>
</ol>
<p><strong>But specifically, I am referring to the efforts we've gone to, in the name of reactivity, to duplicate state and their respective logic on both the server and the client</strong></p>
<p>As a young developer who started working with React more recently, I have heard stories of the comedic struggle from my more experienced colleagues as they have had to migrate between React patterns over the years. The grumblings about having to convert all their class components to functional components with hooks, confusion over lifecycle methods and much more. Hooks feel quite natural to me now as they are all i've ever know, but I can sympathize with how challenging it must have been to refactor your mind as well as a complex codebase.</p>
<p>I came face-to-face with this with React Server Components. Of course, the promise was improved performance and developer experience once adopted, but that did not make the task any less exhausting. Moving everything from the pages router to the new app router in Next.js has really been a fundamental shift in my mental model of the web. But Caleb you say, this is the last of the fundamental changes! We are finally here! Sure... One day, as my collegues complained to me about class components, I will complain to my own about RSCs.</p>
<p>Maybe I am naive, but why should the same state live on the client and the server? Surely there is no need for this. The server can and will update the client once a mutation happens, so you should use this as your place to render your HTML. If you want some reactivity, sure, sprinkle some JS in there. If the state only lives on the client, JavaScript is your friend. In my naive opinion, RSCs are marginally better HTML templates and Server-Actions are magic AJAX requests - all inccuring crazy levels of abstraction. I am not anti-JS, I am anti-unnecessary-complexity.</p>
<h2 id="what-is-the-temporary-standard">What is the Temporary Standard?</h2>
<p>Well, i'm not sure. It's my best guess attempt at creating a set of rules and tools based on my current mental model of the web (which is temporary) by creating a web development approach that minimizes complexity and maximizes performance. Yes, I am also the problem. Some basic principles apply:</p>
<h3 id="whichever-machine-stores-the-state-will-render-the-html">Whichever machine stores the state, will render the HTML</h3>
<p>This doesn't literally mean to render your HTML from stored procedures in your DB, but rather which ever control logic fetches, mutates and stores your data should also return full usable HTML. I can understand some caveats with this approach, but I say to you, [insert something cool here].</p>
<h3 id="javascript-is-good">JavaScript is good</h3>
<p>Reactivity is essential for a rich user experience, and thus JavaScript is an absolute necessity. While you can minimize JavaScript simply by only rendering things on the server by performing a full-page refresh or by using AJAX, this is bad for the user. You shouldn't be performing a round-trip for a singular element to update state that also exists on the client. But, your JavaScript should never create a state in your HTML that isn't re-creatable by the server. Easier said than done. Also, JavaScript is absoloutely needed for accessibility. Ship the JS you need.</p>
<h3 id="performance">Performance</h3>
<p>Don't use a JavaScript backend</p>
<h2 id="how-do-we-achieve-this">How do we achieve this?</h2>
<p>Based on the some of the ideas outligned above we need a backend language that has good templating, a front-end framework that can have state be initialized on the server and tools to aid this interaction. I chose Go, Templ, Lit-Elements, HTMX and some code I cobbled up together.</p>
<ul>
<li><strong>HTMX</strong>: Allows you to perform AJAX requests which return HTML that can be injected in the DOM</li>
<li><strong>Lit-Elements</strong>: Builds on-top of native browser web-components but with property based reactivity</li>
<li><strong>Go</strong>: Well the greatest language on earth</li>
<li><strong>Templ</strong>: Go-like syntax for HTML templating</li>
</ul>
<h2 id="temporary-framework-back-end">Temporary Framework (back-end)</h2>
<p>For the love of God, please do not use this framework. If you've gotten over this small insignificant detail, let's move on. This framework, while being an extension of my first framework <a href="https://gox-framework.org">GoX</a> üíÄüíÄüíÄ, aims to create a tightly coupled experience when working with <a href="https://htmx.org/">HTMX</a>, <a href="https://go.dev/">Go</a> and <a href="https://templ.guide/">Templ</a>. It employs file-based routing, naming conventions similar to <a href="https://nextjs.org/">Next.js</a>, a dynamic server router and some extensions to the Templ library. Below contains some very primitive examples</p>
<h3 id="server-components">Server Components</h3>
<p><a href="https://templ.guide/">Templ</a> provides us a way to encapsulate our render logic and <a href="https://go.dev/">Go</a> allows us to fetch our data. So we get nice separation of concerns for our server components. Consider the following:</p>
<pre><code class="language-go">package home

import (
	&quot;net/http&quot;
	&quot;github.com/a-h/templ&quot;
)

func Page(w http.ResponseWriter, r *http.Request) templ.Component {
	someData := fetchData()

	// perform some validation

	return HomeTempl(someData)
}
</code></pre>
<pre><code class="language-go">package home

templ HomeTempl(names []string) {
	&lt;ul&gt;
		for i := range names {
			&lt;li&gt;
				{ title }
			&lt;/li&gt;
		}
	&lt;/ul&gt;
}
</code></pre>
<p>Apart from the super clean abstraction, you may notice that the <code>Page()</code> function returns a <code>templ.Component</code>. You may be thinking where does this get rendered and served to the user? Well carry on reading.</p>
<h3 id="routing">Routing</h3>
<p>The below directory structure:</p>
<pre><code>app               (1)
 ‚îú‚îÄ index.go
 ‚îú‚îÄ index.templ
 ‚îú‚îÄ home          (2)
 ‚îÇ  ‚îî‚îÄ page.go
 ‚îÇ  ‚îî‚îÄ page.templ
 ‚îî‚îÄ docs          (3)
    ‚îî‚îÄ page.go
    ‚îî‚îÄ page.templ
</code></pre>
<p>Resolves to:</p>
<ol>
<li>
<p><em><strong>/home</strong></em> ‚Üê <code>index.go</code> (1) ‚Üê <code>page.go</code> (2)</p>
</li>
<li>
<p><em><strong>/docs</strong></em> ‚Üê <code>index.go</code> (1) ‚Üê <code>page.go</code> (3)</p>
</li>
</ol>
<p>The <code>temporary framework</code> employs file based routing and will group and serve pages based on directory structure. Additionally, both /home and /docs use the same <code>index.go</code>, so navigation between these routes with <code>hx-boost</code> will always return the needed HTML partials, replacing the body and thus maintaining state and client smoothness.</p>
<h3 id="consider-the-following-example">Consider the following example</h3>
<p>Below is a snippet of the <code>navigation-rail</code> web component from <code>temporary ui</code> used for this website.</p>
<pre><code class="language-html">&lt;t-navigation-rail hx-boost=&quot;true&quot;&gt;
	&lt;t-list-item interactive type=&quot;link&quot; href=&quot;/&quot;&gt;
		Home
		&lt;md-icon slot=&quot;start&quot;&gt;crop_square&lt;/md-icon&gt;
	&lt;/t-list-item&gt;
	&lt;t-list-item interactive type=&quot;link&quot; href=&quot;/projects&quot;&gt;
		Projects
		&lt;md-icon slot=&quot;start&quot;&gt;code_blocks&lt;/md-icon&gt;
	&lt;/t-list-item&gt;
	&lt;t-list-item interactive type=&quot;link&quot; href=&quot;/experience&quot;&gt;
		Experience
		&lt;md-icon slot=&quot;start&quot;&gt;developer_guide&lt;/md-icon&gt;
	&lt;/t-list-item&gt;
&lt;/t-navigation-rail&gt;
</code></pre>
<p>At first glance after seeing the <code>hx-boost</code> attribute you might assume I am doing a soft full-page refresh. That wouldn't be smart. The browser history natively lives on both the client and on the server (per-request), so it makes no sense to send extra HTML to the client and disrupt client-side smoothness (the user will notice). Instead, the <code>temporary framework</code> will hijack the <code>hx-boost</code> attribute, and based on the users file-based-routing, will only update the part of the page needed for navigation. This means the <code>navigation-rail</code> web component updates itself based on the browser <code>pop</code> state event. Additionally, if needed you could initialize this component on the server as such:</p>
<pre><code class="language-html">&lt;t-navigation-rail hx-boost=&quot;true&quot; url=&quot;/projects&quot;&gt;
  ...
&lt;/t-navigation-rail&gt;
</code></pre>
<p>I'm not really bothered to reveal much now, but feel free to watch an explanation of my first framework and a euphoric moment when I first discovered templ.</p>
<p><a href="https://www.youtube.com/watch?v=_gDwxfE5KKU"><img src="https://img.youtube.com/vi/_gDwxfE5KKU/hqdefault.jpg" alt="Introducing GoX" /></a></p>
<p><a href="https://www.youtube.com/watch?v=TtAHz7azOqs"><img src="https://img.youtube.com/vi/TtAHz7azOqs/hqdefault.jpg" alt="Working on a Templ Framework" /></a></p>
<h2 id="temporary-ui-front-end">Temporary UI (front-end)</h2>
<p>A UI library built on top of Google's <a href="https://m3.material.io/">Material 3</a> design standard using <a href="https://lit.dev/">Lit-Elements</a>. Besides styling them to fit my aesthetic, I will be extending them to build small and large components that fit the server/client state ideas mentioned above.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I have a loosely defined standard that I think is pretty future proof and minimally complex. But who am I, many smarter people than me have tried and failed. I have no idea what i'm doing. Stay tuned!</p>
</div></div></div>
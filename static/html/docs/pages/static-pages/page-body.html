<div id='markdown'><h1 id="static-pages-and-routes">Static Pages and Routes</h1>
<p>By <strong>default</strong>, Temporary treats all routes defined in <code>pages.go</code> and <code>route.go</code> as dynamic. This approach ensures that your functions are executed with each request, allowing all operations (like data fetching and mutations) to occur in real-time, thereby guaranteeing the most current data.</p>
<p>The following example illustrates a typical dynamic route scenario:</p>
<pre><code class="language-go">package home

import (
	&quot;net/http&quot;
	&quot;github.com/a-h/templ&quot;
)

func Page(w http.ResponseWriter, r *http.Request) templ.Component {
	someData := fetchNames()

	return NamesList(someData)
}

templ NamesList(names []string){
  &lt;ul&gt;
		for _, n := range names {
			&lt;li&gt;
				{ n }
			&lt;/li&gt;
		}
	&lt;/ul&gt;
  }  
</code></pre>
<h2 id="static">Static</h2>
<p>However, not all routes require real-time data processing. Some serve consistent HTML content, where executing extensive build processes for each request can hamper performance. For these scenarios, Temporary offers a build-time rendering feature. By simply appending an underscore <code>_</code> to your function names in both <code>page.go</code> and <code>route.go</code>, you can render these routes at build-time. This not only generates the full HTML pages but also prepares the partial content necessary for Temporary's <code>hx-boost</code> override, optimizing performance for static content.</p>
<p>Below is an example of a route with an extensive build process, such as converting markdown to a Templ component. This route is used for the page you are currently viewing.</p>
<pre><code class="language-go">package home

import (
	&quot;github.com/a-h/templ&quot;
	&quot;calebsideras.com/temporary/src/utils&quot;
)

func Page_() templ.Component {

	newTempl, err := utils.MdFileToTempl(&quot;path/example.md&quot;)

	if err != nil {
		panic(err)
	}

	return newTempl
}
  
</code></pre>
</div>